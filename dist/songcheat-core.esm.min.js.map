{"version":3,"sources":["../src/utils.js","../src/parser.js","../src/compiler.js"],"names":["Utils","[object Object]","str","this","spaces","length","s","charAt","toUpperCase","slice","firstUpper","camel","toLowerCase","replace","match","group1","char","isNaN","isFinite","Error","i","text1","text2","sepLine","keepEmptyLines","a1","split","a2","map","v","lines","trim","push","join","data","ret","d","encodeURIComponent","code","units","duration","codes","current","rest","durationcode","e","fret","String","fromCharCode","charCodeAt","parseInt","startingFret","char2fret","relFret","fret2char","chord","strings","tablature","name","fingering","result","string","indexOf","mute","ParserException","line","message","Parser_","songcheat","blocks","text","tokens","tokenize","tokenIndex","token","keyword","isKeyword","value","params","handler","handleDefault","call","camelCase","reSpaces","reNewline","lineNumber","parseFloat","handleSignature","beatsPerBar","beatDuration","symbol","comment","id","score","part","phrases","splice","bars","pIndex","param","JSON","parse","stringify","bar","rhythm","chords","parts","substr","found","handleChord","args","Array","prototype","apply","lyrics","Parser","parser_","MIN_LYRICS_BARLEN","LYRICS_SUM_DURATIONS","KEEP_EMPTY_LINES","CompilerException","Compiler_","DEBUG","console","log","arguments","mode","barsPerLine","signature","key","lyricsUnit","time","barDuration","resolveIds","structure","unitsByPart","numberByPart","unit","colors","partIndex","color","rhythms","compileRhythm","phraseIndex","phrase","chordChanges","lastChord","addChordChanges","c","barIndex","chordChangesMode","unitIndex","resolveId","chordId","collection","initialNoteDuration","noteDuration","placeholdercount","position","lastToken","compiledScore","tied","flags","placeholderIndex","flagsString","stroke","accent","pm","flag","o","resetAtBars","offset","note","hidden","defaultCursorStep","warnings","groups","registerGroup","missingDuration","Math","floor","durationcodes","group","groupLength","getGroupLength","plen","max","ceil","p","pmax","chordDuration","g","getChordDisplay","debugText","zeroDuration","toFixed","maxConsecutiveSpaces","showDots","unitText","groupIndex","needFinalSpace","maxLength","min","minLength","filler","groupText","chordInserts","lengthStillToPlaceOnThisGroup","lengthYetPlacedOnThisGroup","chordChange","positionDelta","positionDelta_","chordInsert","skip","unitText_","chordText","inserted","interlace","step","addDuration","Compiler","compiler_","set","title","scc","compile","parseLyrics","getUnitText"],"mappings":"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","sourcesContent":["export class Utils {\n  /**\n  * String helper functions\n  */\n\n  static title (str) {\n    return '\\n' + this.spaces(str.length + 8, '*') + '\\n*** ' + str + ' ***\\n' + this.spaces(str.length + 8, '*') + '\\n'\n  }\n\n  static firstUpper (s) {\n    return s.charAt(0).toUpperCase() + s.slice(1)\n  }\n\n  static camelCase (s, firstUpper) {\n    var camel = s.toLowerCase().replace(/(?:[-_])(.)/g, function (match, group1) { return group1.toUpperCase() })\n    return firstUpper ? camel.charAt(0).toUpperCase() + camel.slice(1) : camel\n  }\n\n  static spaces (length, char) {\n    if (isNaN(length) || !isFinite(length) || length < 0) throw new Error('Length must a positive finite number')\n    var s = ''\n    for (var i = 0; i < length; i++) s += char || ' '\n    return s\n  }\n\n  /**\n   * Interlace two multi line strings: one line of each file in alternance\n   * If the second file contains more line then the first one, these additional lines will be ignored\n   **/\n\n  static interlace (text1, text2, sepLine, keepEmptyLines) {\n    var a1 = text1.split(/\\r?\\n/)\n    var a2 = text2.split(/\\r?\\n/)\n    var a = a1.map(function (v, i) {\n      let lines = keepEmptyLines || (a2[i] && a2[i].trim()) ? [v, a2[i]] : [v]\n      if (typeof sepLine === 'string') lines.push(sepLine)\n      return lines.join('\\n')\n    })\n    return a.join('\\n')\n  }\n\n  /**\n   * Encode given parameters as a GET query string\n   **/\n\n  static encodeQueryData (data) {\n    let ret = []\n    for (let d in data) { ret.push(encodeURIComponent(d) + '=' + encodeURIComponent(data[d])) }\n    return ret.join('&')\n  }\n\n  /**\n   * Convert a duration code to the smallest unit (64th)\n   **/\n\n  static duration (code) {\n    if (code === ':32') return 2\n    if (code === ':16') return 4\n    if (code === ':8') return 8\n    if (code === ':q') return 16\n    if (code === ':h') return 32\n    if (code === ':w') return 64\n\n    if (code === ':32d') return 3\n    if (code === ':16d') return 6\n    if (code === ':8d') return 12\n    if (code === ':qd') return 24\n    if (code === ':hd') return 48\n    if (code === ':wd') return 96\n\n    throw new Error('Invalid duration code \"' + code + '\"')\n  }\n\n  /**\n   * Convert back a number of units (64th) into a duration code\n   **/\n\n  static durationcode (units) {\n    for (let code of ['w', 'h', 'q', '8', '16', '32']) {\n      if (this.duration(':' + code) === units) return ':' + code\n      if (this.duration(':' + code + 'd') === units) return ':' + code + 'd'\n    }\n\n    throw new Error('Could not find a code with a value of ' + units + ' units')\n  }\n\n  /**\n   * Convert a number of units (64th) into one or several duration codes\n   **/\n\n  static durationcodes (units) {\n    var codes = []\n\n    var current = units\n    var rest = 0\n\n    while (current > 0) {\n      try {\n        codes.push(this.durationcode(current))\n        current = rest\n        rest = 0\n      } catch (e) {\n        current--\n        rest++\n      }\n    }\n\n    if (rest > 0) throw new Error('Could not find codes adding to a value of ' + units + ' units')\n\n    return codes\n  }\n\n  /**\n   * Convert a fret number (up to 35) to a single char (digit or capital letter)\n   * Fret 10 is notated as A, 11 as B, ... and 35 as Z\n   */\n\n  static fret2char (fret) {\n    if (isNaN(fret) || fret < 0 || fret > 35) throw new Error('Cannot convert fret number ' + fret + ' to a single char (expected a value between 0 and 35)')\n    return fret < 10 ? '' + fret : String.fromCharCode('A'.charCodeAt(0) + fret - 10)\n  }\n\n  /**\n   * Convert a single char (digit or capital letter) to a fret number\n   * A means fret 10, 11 fret B, ... and Z fret 35\n   */\n\n  static char2fret (char) {\n    if (typeof char !== 'string') throw new Error('Invalid fret char ' + char + ' expected a string')\n    if (!char.match(/^[0-9A-Z]$/)) throw new Error('Invalid fret char ' + char + ' (expected a value between [0-9] or [A-Z])')\n    return char >= 'A' ? 10 + char.charCodeAt(0) - 'A'.charCodeAt(0) : parseInt(char, 10)\n  }\n\n  /**\n   * Convert an absolute fret number (single char) to a relative fret number (0 never changes)\n   */\n\n  static abs2rel (char, startingFret) {\n    let fret = this.char2fret(char)\n    if (isNaN(fret) || fret < 0) throw new Error('Invalid fret number ' + fret + ' (expected a positive or 0 integer value)')\n    if (fret === 0) return 0\n    if (isNaN(startingFret) || startingFret < 0) throw new Error('Invalid starting fret number ' + startingFret + ' (expected a positive or 0 integer value)')\n    if (startingFret + 8 < fret || startingFret > fret) throw new Error('Fret ' + fret + ' cannot be made relative to starting fret ' + startingFret + ' within the allowed range of 1 to 9')\n    return fret + 1 - startingFret\n  }\n\n  /**\n   * Convert a relative fret number to an absolute fret number (single char) (0 never changes)\n   */\n\n  static rel2abs (relFret, startingFret) {\n    return this.fret2char(relFret ? relFret + startingFret - 1 : relFret)\n  }\n\n  /**\n   * Take a chord and a placeholder contents\n   * Return an array containing one object { string, fret, mute } for each played string\n   */\n\n  static chordStrings (chord, strings) {\n    if (!chord.tablature) throw new Error('Tablature not defined for chord ' + chord.name)\n    if (!chord.fingering) throw new Error('Fingering not defined for chord ' + chord.name)\n\n    var result = []\n    for (var i = 0; i < chord.tablature.length; i++) {\n      // string will be between 6 and 1 since chord.tablature.length has been verified and is 6\n      var string = 6 - i\n\n      // string never played in this chord\n      if (chord.tablature[i] === 'x') continue\n\n      // first time we meet a played string, it's the bass so replace B and B' with the string number\n      strings = strings.replace(/B'/g, (string >= 5 ? string - 1 : string))\n      strings = strings.replace(/B/g, string)\n\n      // check if this string should be played with the right hand\n      // * means \"all strings\", otherwise concatenated specific string numbers are specified (or B for bass or B' for alternate bass)\n      // x after string means muted (ghost) note\n      if (strings.match(/^\\*/) || strings.indexOf(string) !== -1) {\n        let fret = this.char2fret(chord.tablature[i])\n        let xIndex = strings.match(/^\\*/) ? 1 : strings.indexOf(string) + 1\n        let mute = strings[xIndex] === 'x'\n        result.push({\n          string: string,\n          fret: fret,\n          mute: mute\n        })\n      }\n    }\n\n    return result\n  }\n}\n","import { Utils } from './utils'\n\nexport class ParserException {\n  constructor (line, message) {\n    this.message = message\n    this.line = line\n  }\n\n  toString () {\n    return 'Parser error at line ' + this.line + ': ' + this.message\n  }\n}\n\nclass Parser_ {\n  constructor () {\n    this.songcheat = {}\n    this.blocks = {}\n  }\n\n  parse (text) {\n    // reset\n    this.songcheat = {}\n    this.blocks = {}\n\n    // split text into tokens\n    let tokens = this.tokenize(text)\n    if (tokens.length === 0) return true\n\n    let tokenIndex = 0\n    while (tokenIndex < tokens.length) {\n      let token = tokens[tokenIndex]\n      let keyword = this.isKeyword(token)\n\n      // we must be on a keyword, otherwise it means that first token in text is not a keyword as expected\n      if (!keyword) throw new ParserException(token.line, 'expected keyword, found \"' + token.value + '\"')\n\n      // get all tokens until next keyword or end\n      let params = []\n      for (++tokenIndex; tokenIndex < tokens.length; ++tokenIndex) {\n        if (this.isKeyword(tokens[tokenIndex])) break\n        params.push(tokens[tokenIndex])\n      }\n\n      // use specific handler if any or default one\n      let handler = this['handle' + Utils.firstUpper(keyword)] || this.handleDefault\n      if (typeof handler === 'function') handler.call(this, token.line, keyword, params)\n      else throw new ParserException(token.line, 'non function handler found for keyword ' + keyword)\n    }\n\n    return this.songcheat\n  }\n\n  isKeyword (token) {\n    let keyword = Utils.camelCase(token.value)\n    return ['artist', 'title', 'year', 'difficulty', 'video', 'tutorial', 'comment', 'tuning', 'capo', 'key', 'time', 'tempo', 'shuffle', 'chord', 'rhythm', 'block', 'part', 'lyricsUnit' /* will disappear soon */, 'structure'].indexOf(keyword) >= 0 ? keyword : false\n  }\n\n  tokenize (text) {\n    let tokens = []\n\n    // https://stackoverflow.com/questions/4780728/regex-split-string-preserving-quotes?noredirect=1&lq=1\n    let reSpaces = /(?<=^[^\"]*(?:\"[^\"]*\"[^\"]*)*)[\\s\\t]+(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/\n    let reNewline = /(?<=^[^\"]*(?:\"[^\"]*\"[^\"]*)*)(\\r?\\n)(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/\n\n    let lineNumber = 1\n\n    // split at newlines unless enclosed in quotes\n    for (let line of text.split(reNewline)) {\n      // split also returns the newlines, ignore them\n      if (line.match(/^\\r?\\n$/)) continue\n\n      // trim line\n      line = line.trim()\n\n      // console.log(\"L\" + lineNumber + \": [\"+ line + \"]\");\n\n      // if not a comment or empty line\n      if (line && !line.match(/^#/)) {\n        // split at spaces and tabs unless enclosed in quotes, then trim spaces and quotes\n        for (let value of line.split(reSpaces).map(s => s.trim().replace(/^\"|\"$/g, ''))) tokens.push({ 'value': value, 'line': lineNumber })\n      }\n\n      // increment line number\n      lineNumber += (1 + (line.match(/(?:\\r?\\n)/g) || []).length)\n    }\n\n    return tokens\n  }\n\n  handleDefault (line, keyword, params) {\n    if (params.length !== 1) throw new ParserException(line, keyword.toUpperCase() + ' expected exactly 1 value, but found ' + params.length)\n    this.songcheat[keyword] = ['year', 'capo', 'difficulty'].indexOf(keyword) >= 0 ? parseInt(params[0].value, 10) : params[0].value\n  }\n\n  handleSignature (line, keyword, params) {\n    if (params.length !== 1) throw new ParserException(line, keyword.toUpperCase() + ' expected exactly 1 value, but found ' + params.length)\n    this.songcheat['signature'] = this.songcheat['signature'] || {}\n    this.songcheat['signature'][keyword] = keyword === 'tempo' ? parseFloat(params[0].value, 10) : params[0].value\n  }\n\n  handleKey (line, keyword, params) { return this.handleSignature(line, keyword, params) }\n  handleTempo (line, keyword, params) { return this.handleSignature(line, keyword, params) }\n  handleShuffle (line, keyword, params) { return this.handleSignature(line, keyword, params) }\n\n  handleTime (line, keyword, params) {\n    if (params.length !== 3) throw new ParserException(line, keyword.toUpperCase() + ' expected exactly 3 values, but found ' + params.length)\n    this.songcheat['signature'] = this.songcheat['signature'] || []\n    this.songcheat['signature']['time'] = { 'beatsPerBar': params[1].value, 'beatDuration': params[2].value, 'symbol': params[0].value }\n  }\n\n  handleChord (line, keyword, params) {\n    if (params.length < 2 || params.length > 4) throw new ParserException(line, keyword.toUpperCase() + ' expected between 2 and 4 values (name, tablature[, fretting=\"000000/-\", comment=\"\"]), but found ' + params.length)\n\n    let name = params[0].value\n    let tablature = params[1].value\n    let fingering = params.length >= 3 ? params[2].value : '000000/-'\n    let comment = params.length >= 4 ? params[3].value : ''\n\n    this.songcheat['chords'] = this.songcheat['chords'] || []\n    let chord = { 'id': this.songcheat['chords'].length + 1, 'name': name, 'tablature': tablature, 'fingering': fingering, 'comment': comment }\n    this.songcheat['chords'].push(chord)\n\n    // return created chord (used when meeting an inline chord)\n    return chord\n  }\n\n  handleRhythm (line, keyword, params) {\n    if (params.length !== 2) throw new ParserException(line, keyword.toUpperCase() + ' expected exactly 2 values (id and score), but found ' + params.length)\n    this.songcheat['rhythms'] = this.songcheat['rhythms'] || []\n    this.songcheat['rhythms'].push({ 'id': this.songcheat['rhythms'].length + 1, 'name': params[0].value, 'score': params[1].value })\n  }\n\n  handleBlock (line, keyword, params) {\n    if (params.length < 2) throw new ParserException(line, keyword.toUpperCase() + ' expected at least 2 values (name and bar(s)), but found ' + params.length)\n    this.blocks[params[0].value] = params.slice(1)\n  }\n\n  handlePart (line, keyword, params) {\n    if (params.length < 2) throw new ParserException(line, keyword.toUpperCase() + ' expected at least 2 values (name and bar(s)), but found ' + params.length)\n    this.songcheat['parts'] = this.songcheat['parts'] || []\n\n    // extract part name from params\n    let part = { 'id': this.songcheat['parts'].length + 1, 'name': params[0].value, 'phrases': [] }\n    params = params.splice(1)\n    this.songcheat['parts'].push(part)\n\n    // iterate on remaining params to get bars and phrases\n    let bars = []\n    for (let pIndex = 0; pIndex < params.length; pIndex++) {\n      let param = params[pIndex]\n\n      // phrase separator\n      if (param.value === '||') {\n        part.phrases.push({ 'bars': bars })\n        bars = []\n        continue\n      }\n\n      // bar repeater\n      if (param.value === '%') {\n        if (bars.length === 0) throw new ParserException(param.line, 'found bar repeater ' + param.value + ' but there is no bar yet in phrase')\n        bars.push(JSON.parse(JSON.stringify(bars[bars.length - 1])))\n        continue\n      }\n\n      // bar between []\n      if (param.value.match(/^\\[[^[\\]]+\\]$/)) {\n        let bar = { 'rhythm': null, 'chords': [] }\n        let str = param.value.substr(1, param.value.length - 2)\n        let parts = str.split(/\\*|:/)\n\n        // find rhythm\n        let found = false\n        for (let rhythm of this.songcheat['rhythms']) {\n          if (rhythm.name === parts[0]) {\n            bar.rhythm = rhythm.id\n            found = true\n            break\n          }\n        }\n\n        if (!found) throw new ParserException(param.line, parts[0] + ' is not the name of an existing rhythm')\n\n        // find chords\n        parts = parts.slice(1)\n        for (let part of parts) {\n          // chord repeater\n          if (!part.trim()) {\n            if (bar.chords.length === 0) throw new ParserException(param.line, 'found chord repeater but there is no chord yet in bar')\n            bar.chords.push(JSON.parse(JSON.stringify(bar.chords[bar.chords.length - 1])))\n            continue\n          }\n\n          // search for chord by its name\n          let found = false\n          for (let chord of this.songcheat['chords']) {\n            if (chord.name === part) {\n              bar.chords.push(chord.id)\n              found = true\n              break\n            }\n          }\n\n          // if no chord found with this name but this is a valid chord tablature (with an optional barred fret /[-0-9A-Z])\n          if (!found && part.match(/^[x0-9A-Z]{6}(\\/[-0-9A-Z])?$/)) {\n            // create inline chord with the name being the tablature itself, and no fingering nor comment\n            let chord = this.handleChord(param.line, 'chord', [{ value: part, line: param.line }, { value: part.split('/')[0], line: param.line }, { value: '000000/' + (part.split('/')[1] || '-'), line: param.line }])\n            bar.chords.push(chord.id)\n            found = true\n          }\n\n          if (!found) throw new ParserException(param.line, part + ' is not the name of an existing chord and is not a valid chord tablature')\n        }\n\n        bars.push(bar)\n        continue\n      }\n\n      // not a || phrase separator nor a [] bar: must be a block name\n      if (!this.blocks[param.value]) throw new ParserException(param.line, param.value + ' is not the name of an existing block')\n\n      // insert block tokens in params at current position\n      let args = [pIndex, 1]\n      Array.prototype.push.apply(args, this.blocks[param.value])\n      Array.prototype.splice.apply(params, args)\n      pIndex--\n    }\n\n    // end of last phrase\n    if (bars.length > 0) part.phrases.push({ 'bars': bars })\n  }\n\n  handleStructure (line, keyword, params) {\n    if (params.length < 2) throw new ParserException(line, keyword.toUpperCase() + ' expected at least 2 values (part name and lyrics), but found ' + params.length)\n    if (params.length % 2 !== 0) throw new ParserException(line, keyword.toUpperCase() + ' expected an even number of parameters (N x part name and lyrics), but found ' + params.length)\n    this.songcheat['structure'] = this.songcheat['structure'] || []\n\n    for (let pIndex = 0; pIndex < params.length; pIndex += 2) {\n      let param = params[pIndex]\n\n      let found = false\n      for (let part of this.songcheat['parts']) {\n        if (part.name === param.value) {\n          this.songcheat['structure'].push({ 'part': part.id, 'lyrics': params[pIndex + 1].value })\n          found = true\n          break\n        }\n      }\n\n      if (!found) throw new ParserException(param.line, param.value + '\" is not the name of an existing part')\n    }\n  }\n}\n\n/**\n * Public API\n */\n\nexport class Parser {\n  constructor () {\n    this.parser_ = new Parser_()\n  }\n\n  parse (songcheat) {\n    return this.parser_.parse(songcheat)\n  }\n}\n","import { Utils } from './utils'\n\nlet MIN_LYRICS_BARLEN = 20 // minimum length of a bar lyrics (before reducing) - not really needed but produces a clearer view when maxConsecutiveSpaces set to 0 (and thus when displaying parts with partdisplay=full) since bars with no or little text will have the same length (unless there are really many chord changes...)\nlet LYRICS_SUM_DURATIONS = false // if true \"::\" is equivalent to \":h:\" (assuming lyrics unit is :q)\nlet KEEP_EMPTY_LINES = false\n\nexport class CompilerException {\n  constructor (message) {\n    this.message = message\n  }\n\n  toString () {\n    return 'Compiler error: ' + this.message\n  }\n}\n\nclass Compiler_ {\n  constructor (DEBUG) {\n    // DEBUG 1 forces showing . * | characters in unit text (even if showDots is passed false) as well as _ for groups that were automatically created when crossing a bar\n    this.DEBUG = DEBUG\n  }\n\n  log () {\n    if (this.DEBUG > 0) console.log.apply(console, arguments)\n  }\n\n  compile (songcheat) {\n    // default values for optional properties\n    songcheat.mode = songcheat.mode || 'rt'\n    songcheat.barsPerLine = songcheat.barsPerLine || 4\n    songcheat.signature.key = songcheat.signature.key || 'C'\n    songcheat.lyricsUnit = songcheat.lyricsUnit || songcheat.signature.time.beatDuration\n\n    // deduce bar duration from signature\n    songcheat.barDuration = songcheat.signature.time.beatsPerBar * Utils.duration(songcheat.signature.time.beatDuration)\n\n    // resolve all id references (rhythms and chords)\n    this.resolveIds(songcheat)\n\n    // default structure if not specified : one unit for each part\n    if (!songcheat.parts) {\n      songcheat.parts = []\n      for (let part of songcheat.parts) songcheat.structure.push({ 'part': part })\n    }\n\n    // give a name to each unit if not already set = name of part with automatic numbering\n    let unitsByPart = {}\n    let numberByPart = {}\n    for (let unit of songcheat.structure) unitsByPart[unit.part.id] = typeof unitsByPart[unit.part.id] === 'undefined' ? 1 : unitsByPart[unit.part.id] + 1\n    for (let unit of songcheat.structure) {\n      numberByPart[unit.part.id] = typeof numberByPart[unit.part.id] === 'undefined' ? 1 : numberByPart[unit.part.id] + 1\n      if (!unit.name) unit.name = unit.part.name + (unitsByPart[unit.part.id] > 1 ? ' ' + numberByPart[unit.part.id] : '')\n    }\n\n    // give a color to each part if not already set\n    let colors = ['red', '#06D6A0', 'blue', 'purple', 'orange', 'magenta']\n    let partIndex = 0\n    for (let part of songcheat.parts) { if (!part.color) part.color = colors[partIndex++ % colors.length] }\n\n    // validate and compile each rhythm\n    for (let rhythm of songcheat.rhythms) this.compileRhythm(rhythm, songcheat.signature.time.beatDuration)\n\n    for (let part of songcheat.parts) {\n      // compute a \"chordChanges\" property in each phrase\n      let phraseIndex = 0\n      for (let phrase of part.phrases) {\n        phrase.chordChanges = []\n        let lastChord = null\n        for (let bar of phrase.bars) lastChord = this.addChordChanges(bar, phrase.chordChanges, songcheat.barDuration, false, lastChord)\n\n        this.log('Phrase wise chord durations for phrase ' + part.name + '.' + (phraseIndex + 1))\n        for (let c of phrase.chordChanges) this.log('\\t[' + c.chord.name + '] = ' + c.duration + ' units')\n\n        // compute a \"chordChanges\" property in each bar\n        let barIndex = 0\n        for (let bar of phrase.bars) {\n          bar.chordChanges = { 'bar': [], 'rhythm': [] }\n          for (let chordChangesMode of ['rhythm', 'bar']) this.addChordChanges(bar, bar.chordChanges[chordChangesMode], songcheat.barDuration, chordChangesMode === 'bar')\n\n          this.log('\\tRythm wise chord durations for bar ' + part.name + '.' + (phraseIndex + 1) + '.' + (barIndex + 1))\n          for (let c of bar.chordChanges['rhythm']) this.log('\\t\\t[' + c.chord.name + '] = ' + c.duration + ' units')\n          this.log('\\tBar wise chord durations for bar ' + part.name + '.' + (phraseIndex + 1) + '.' + (barIndex + 1))\n          for (let c of bar.chordChanges['bar']) this.log('\\t\\t[' + c.chord.name + '] = ' + c.duration + ' units')\n\n          barIndex++\n        }\n\n        phraseIndex++\n      }\n\n      // compute duration of part\n      part.duration = 0\n      for (let phrase of part.phrases) { for (let bar of phrase.bars) part.duration += bar.rhythm.duration }\n    }\n\n    // fluid API\n    return songcheat\n  }\n\n  resolveIds (songcheat) {\n    let unitIndex = 0\n    for (let unit of songcheat.structure) {\n      if (!unit.part) throw new CompilerException('Part not defined for unit ' + (unitIndex + 1))\n\n      // resolve part id\n      let part = this.resolveId(songcheat.parts, unit.part)\n      if (!part) throw new CompilerException('Part ' + unit.part + ' not found')\n      unit.part = part\n\n      unitIndex++\n    }\n\n    for (let part of songcheat.parts) {\n      if (!part.phrases) throw new CompilerException('Phrases not defined for part \"' + part.name + '\"')\n      if (!(part.phrases instanceof Array)) throw new CompilerException('Phrases defined for part \"' + part.name + '\" must be an Array, found: ' + (typeof songcheat.parts.phrases))\n\n      let phraseIndex = 0\n      for (let phrase of part.phrases) {\n        let barIndex = 0\n        for (let bar of phrase.bars) {\n          if (!bar.rhythm) throw new CompilerException('Rhythm not defined for bar ' + (barIndex + 1) + ' of phrase ' + (phraseIndex + 1) + ' of ' + part.name)\n          if (!bar.chords) throw new CompilerException('Chords not defined for bar ' + (barIndex + 1) + ' of phrase ' + (phraseIndex + 1) + ' of ' + part.name)\n          if (!(bar.chords instanceof Array)) throw new CompilerException('Chords defined for bar ' + (barIndex + 1) + ' of phrase ' + (phraseIndex + 1) + ' must be an Array, found: ' + (typeof bar.chords))\n\n          // resolve rhythm id\n          let rhythm = this.resolveId(songcheat.rhythms, bar.rhythm)\n          if (!rhythm) throw new CompilerException('Rhythm ' + bar.rhythm + ' not found for bar ' + (barIndex + 1) + ' of phrase ' + (phraseIndex + 1))\n          bar.rhythm = rhythm\n\n          // resolved array of chord ids\n          let chords = []\n          for (let chordId of bar.chords) {\n            // resolve chord id\n            let chord = this.resolveId(songcheat.chords, chordId)\n            if (!chord) throw new CompilerException('Chord ' + chordId + ' not found for bar ' + (barIndex + 1) + ' of phrase ' + (phraseIndex + 1))\n            chords.push(chord)\n          }\n\n          bar.chords = chords\n          barIndex++\n        }\n\n        phraseIndex++\n      }\n    }\n  }\n\n  resolveId (collection, id) {\n    if (collection) { for (let i of collection) { if (i.id === id) return i } }\n    return null\n  }\n\n  compileRhythm (rhythm, initialNoteDuration) {\n    this.log('Compiling rhythm ' + rhythm.id + ' with score \"' + rhythm.score + '\"')\n\n    // default note duration, until changed\n    let noteDuration = initialNoteDuration\n\n    // take not of each placeholder's index, so we can later fetch the associated chord\n    rhythm.placeholdercount = 0\n\n    // for locating syntax errors in message\n    let position = 1\n    let lastToken = null\n\n    // compile the score string into an array of objects\n    rhythm.compiledScore = []\n    for (let token of rhythm.score.split(/((?::(?:w|h|q|8|16|32)d?)|\\(#\\)|T?\\s*\\([^(]*\\)[^()\\sT:]*)/)) {\n      if ((token = token.trim())) {\n        let match = null\n        if ((match = token.match(/^(:(?:w|h|q|8|16|32)d?)$/))) {\n          // duration: change note duration to use next\n          noteDuration = Utils.duration(match[1])\n        } else if ((match = token.match(/^\\(#\\)$/))) {\n          // rest\n          rhythm.compiledScore.push({ rest: true, duration: noteDuration, tied: false, strings: false, flags: {}, placeholderIndex: rhythm.placeholdercount++ })\n        } else if ((match = token.match(/^(T?)\\s*\\(([^(]*)\\)([^()\\s]*)$/))) {\n          // chord placeholder\n          let tied = match[1] === 'T'\n\n          // strings = between parentheses\n          let strings = match[2]\n          if (strings === '') strings = '*' // an empty string is a shortcut for \"*\"\n          if (strings === 'x') strings = '*x' // a x alone is a shortcut for \"*x\"\n          if (!strings.match(/^(?:(\\*x?)|((?:(?:B|B'|1|2|3|4|5|6)x?)+))$/)) throw new CompilerException('Invalid syntax found in chord placeholder: ' + strings)\n\n          // flags = after parentheses\n          let flagsString = match[3]\n          let flags = { stroke: null, accent: false, pm: false, fingering: null }\n          for (let flag of flagsString.split(/(dd?|uu?|>|PM|[pima]+)/)) {\n            if (flag.trim()) {\n              if (flag.match(/^(dd?|uu?)$/g)) {\n                // stroke mode\n                if (flags.fingering) throw new CompilerException('Fingering (' + flags.fingering + ') and stroke (' + flag + ') cannot be both defined for the chord placeholder: ' + token)\n                if (flags.pm) throw new CompilerException('Palm muting (PM) and stroke (' + flag + ') cannot be both defined for the chord placeholder: ' + token)\n                if (flags.stroke) throw new CompilerException('More than one stroke mode (d, u, dd, uu) defined for the chord placeholder: ' + token)\n                flags.stroke = flag\n              } else if (flag.match(/^[pima]+$/)) {\n                // PIMA fingering\n                if (flags.stroke) throw new CompilerException('Stroke (' + flags.stroke + ') and fingering (' + flag + ') cannot be both defined for the chord placeholder: ' + token)\n                if (flags.pm) throw new CompilerException('Palm muting (PM) and fingering (' + flag + ') cannot be both defined for the chord placeholder: ' + token)\n                if (flags.fingering) throw new CompilerException('More than one fingering (pima) defined for the chord placeholder: ' + token)\n                flags.fingering = flag\n              } else if (flag.match(/^PM$/)) {\n                // palm muting\n                if (flags.stroke) throw new CompilerException('Stroke (' + flags.stroke + ') and palm muting (' + flag + ') cannot be both defined for the chord placeholder: ' + token)\n                if (flags.fingering) throw new CompilerException('Fingering (' + flags.fingering + ') and palm muting (' + flag + ') cannot be both defined for the chord placeholder: ' + token)\n                if (flags.pm) throw new CompilerException('More than one palm muting (PM) defined for the chord placeholder: ' + token)\n                flags.pm = true\n              } else if (flag.match(/^>$/)) {\n                // accent\n                if (flags.accent) throw new CompilerException('More than one accent (>) defined for the same placeholder: ' + token)\n                flags.accent = true\n              } else throw new CompilerException('Invalid flag \"' + flag + '\" defined for chord placeholder \"' + token + '\"')\n            }\n          }\n\n          // add a note\n          rhythm.compiledScore.push({ rest: false, duration: noteDuration, tied: tied, strings: strings, flags: flags, placeholderIndex: rhythm.placeholdercount++ })\n        } else throw new CompilerException('Invalid token \"' + token + '\" in rhythm score definition at position ' + position + (lastToken ? ' (after \"' + lastToken + '\")' : ''))\n\n        lastToken = token\n      }\n\n      position += token.length\n    }\n\n    // compute total rhythm duration\n    rhythm.duration = 0\n    for (let o of rhythm.compiledScore) rhythm.duration += o.duration\n  }\n\n  addChordChanges (bar, chordChanges, barDuration, resetAtBars, lastChord) {\n    // ensure number of chords match number of placeholders in rhythm score, by repeating last chord\n    if (bar.chords.length < 1) throw new CompilerException('chords must contain at least 1 entry, but ' + bar.chords.length + ' were found')\n    while (bar.chords.length < bar.rhythm.placeholdercount) bar.chords.push(bar.chords[bar.chords.length - 1])\n\n    let offset = 0\n    for (let note of bar.rhythm.compiledScore) {\n      // get chord corresponding to the placeholder position\n      let chord = bar.chords[note.placeholderIndex]\n      if (!chord) throw new CompilerException('No chord found for placeholder ' + (note.placeholderIndex + 1))\n\n      // same chord as before and not a new bar: increment duration with this new note\n      if (lastChord === chord && offset % barDuration !== 0) chordChanges[chordChanges.length - 1].duration += note.duration\n\n      // chord changed: new duration starts with one note of the new chord\n      // unless requested to reset chords at bars, chord change will be hidden if still the same as before\n      else chordChanges.push({ chord: chord, duration: note.duration, hidden: lastChord === chord && !resetAtBars })\n\n      lastChord = chord\n      offset += note.duration\n    }\n\n    return lastChord\n  }\n\n  parseLyrics (unit, defaultCursorStep, barDuration) {\n    let warnings = []\n    let offset = 0\n\n    // remove DOS newlines\n    unit.lyrics = (unit.lyrics || '').replace(/\\r/g, '')\n\n    // split lyrics into word groups, split occurs at cursor forward instructions (colons, durations and bars)\n    unit.groups = []\n    for (let part of unit.lyrics.split(/((?::(?:w|h|q|8|16|32)d?)?:|\\|)/)) { // nb: split with capture groups only works in decent browsers, e.g. IE10+\n      let match = null\n      // move cursor forward by given or default step duration\n      if ((match = part.match(/(:(?:w|h|q|8|16|32)d?)?:/))) offset = this.registerGroup(unit, offset, match[1] ? Utils.duration(match[1]) : defaultCursorStep, barDuration)\n\n      // move cursor to begin of next bar\n      else if (part.match(/\\|/)) offset = this.registerGroup(unit, offset, barDuration - (offset % barDuration), barDuration)\n\n      // (non empty) word group (waiting for its duration)\n      else if (part.length > 0) unit.groups.push({ text: part, offset: offset, duration: 0 })\n    }\n\n    // simulate a final bar if last group still open (no duration), i.e. if lyrics do not end on a : or |\n    if (unit.groups.length && unit.groups[unit.groups.length - 1].duration === 0) offset = this.registerGroup(unit, offset, barDuration - (offset % barDuration), barDuration)\n\n    // get missing duration and complete with empty groups if needed (offset now contains the total duration of all groups)\n    let missingDuration = unit.part.duration - offset\n    this.log('[' + unit.name + '] Missing duration = ' + missingDuration + ' units (' + unit.part.duration + ' - ' + offset + ') = ' + (missingDuration / barDuration) + ' bars missing')\n    if (missingDuration < 0) warnings.push('Lyrics contain ' + Math.floor(-missingDuration / barDuration) + ' bar(s)' + (-missingDuration % barDuration ? ' and ' + Utils.durationcodes(-missingDuration % barDuration) : '') + ' in excess')\n    offset = this.registerGroup(unit, offset, missingDuration, barDuration)\n\n    for (let group of unit.groups) {\n      // compute length of group (in chars), adding 1 so the group having max density is not collated with next group\n      let groupLength = this.getGroupLength(group) + 1\n\n      // ensure the bar will always have the required minimal width\n      group.plen = Math.max(groupLength, Math.ceil(MIN_LYRICS_BARLEN * group.duration / barDuration))\n\n      // compute density of group based on the obtained length\n      group.p = group.plen / group.duration\n\n      // set bar true if group ends on a bar\n      group.bar = (group.offset + group.duration) % barDuration === 0\n\n      // initialize chord changes\n      group.chordChanges = { 'bar': [], 'rhythm': [], 'phrase': [] }\n    }\n\n    // compute maximum density across all groups\n    unit.pmax = 0\n    for (let group of unit.groups) unit.pmax = Math.max(unit.pmax, group.p)\n\n    // iterate on each phrase wise chord change and find the associated group\n    offset = 0\n    for (let phrase of unit.part.phrases) {\n      for (let chordDuration of phrase.chordChanges) {\n        // find closest group starting at or before chord offset\n        let group = null\n        for (let g of unit.groups) { if (g.offset <= offset) group = g }\n        if (!group) throw new Error('No closest group found for chord ' + chordDuration.chord.name + ' with offset ' + offset + ' units')\n\n        // register chord change in group\n        group.chordChanges['phrase'].push({ offset: offset, text: this.getChordDisplay(chordDuration) })\n\n        offset += chordDuration.duration\n      }\n    }\n\n    // iterate on each bar wise chord change and find the associated group\n    offset = { 'rhythm': 0, 'bar': 0 }\n    for (let phrase of unit.part.phrases) {\n      for (let bar of phrase.bars) {\n        for (let chordChangesMode of ['rhythm', 'bar']) {\n          for (let chordDuration of bar.chordChanges[chordChangesMode]) {\n            // find closest group starting at or before chord offset\n            let group = null\n            for (let g of unit.groups) { if (g.offset <= offset[chordChangesMode]) group = g }\n            if (!group) throw new Error('No closest group found for chord ' + chordDuration.chord.name + ' with offset ' + offset[chordChangesMode] + ' units')\n\n            // register chord change in group\n            group.chordChanges[chordChangesMode].push({ offset: offset[chordChangesMode], text: this.getChordDisplay(chordDuration) })\n\n            offset[chordChangesMode] += chordDuration.duration\n          }\n        }\n      }\n    }\n\n    // debug info\n    var debugText = 'Groups of unit [' + unit.name + ']:\\n'\n    var barIndex = 0\n    let zeroDuration = false\n    for (let group of unit.groups) {\n      debugText += '\\tBar ' + (barIndex + 1) + '\\t[' + group.text.replace(/\\n/g, '\\\\N') + ']:' + group.duration + ' (' + group.offset + ' - ' + (group.offset + group.duration) + ') L=' + this.getGroupLength(group) + \" L'=\" + group.plen + ' ρ=' + group.p.toFixed(2) + ' #Chord changes %bar= ' + group.chordChanges['bar'].length + ' %phrase= ' + group.chordChanges['phrase'].length\n      if (group.duration === 0) zeroDuration = true\n      if (group.bar) {\n        barIndex++\n        debugText += ' | '\n      }\n      debugText += '\\n'\n    }\n    debugText += 'ρ max = ' + unit.pmax.toFixed(2)\n    this.log(debugText)\n\n    if (zeroDuration) throw new Error('Detected group with 0 duration')\n\n    return warnings\n  }\n\n  getUnitText (unit, maxConsecutiveSpaces, split, chordChangesMode, showDots) {\n    var unitText = ''\n\n    // concatenate lyrics groups, giving them a number of positions proprtional to their duration\n    var barIndex = 0\n    var groupIndex = 0\n    for (let group of unit.groups) {\n      // where and on how many positions will this group be displayed\n      group.position = [...unitText.replace(/\\n/g, '')].length\n      group.length = Math.ceil(group.duration * unit.pmax)\n\n      // an hyphen means a word has been cut in two, no need for a space before next group\n      // but if the final character should be a bar, then always count this extra character\n      let needFinalSpace = group.bar || !group.text.match(/-$/)\n\n      // if maxConsecutiveSpaces is set, set a maximum for the number of allowed positions if needed\n      let maxLength = null\n      if (maxConsecutiveSpaces > 0) maxLength = this.getGroupLength(group) + maxConsecutiveSpaces - (needFinalSpace ? 0 : 1)\n      if (maxLength) group.length = Math.min(group.length, maxLength)\n\n      // but if group has associated chords, we must have enough space for them (and this has priority over maxConsecutiveSpaces)\n      let minLength = group.bar ? 1 : 0 // 1 for the final bar sign if any\n      if (group.chordChanges[chordChangesMode]) { for (let i = 0; i < group.chordChanges[chordChangesMode].length; i++) minLength += group.chordChanges[chordChangesMode][i].text.length }\n      minLength = Math.max(this.getGroupLength(group) + (needFinalSpace ? 1 : 0), minLength)\n      group.length = Math.max(group.length, minLength)\n\n      // filler string used to reach that length (nb: filler will always have a length of at least 1)\n      let filler = Utils.spaces(group.length - this.getGroupLength(group), showDots || this.DEBUG ? '.' : ' ')\n\n      // replace last character of filler by a | if this is the end of a bar\n      filler = filler.replace(/(.)$/, group.bar ? (split > 0 && ((barIndex + 1) % split === 0) ? '|\\n' : '|') : (this.DEBUG ? '*' : '$1'))\n\n      // append filler to text, remove new lines if splitting at bars\n      var groupText = (split > 0 ? group.text.replace(/\\n/g, '') : group.text) + filler\n\n      this.log('[' + unit.name + '] Display group ' + (groupIndex + 1) + ' \"' + groupText.replace(/\\n/g, '\\\\N') + '\" on ' + group.length + ' chars (CEIL ' + (group.duration * unit.pmax).toFixed(2) + ' MIN ' + minLength + ' MAX ' + (maxLength || 'n/a') + ')')\n      unitText += groupText\n\n      groupIndex++\n      if (group.bar) barIndex++\n    }\n\n    // we weren't asked to add chords\n    if (!chordChangesMode) return unitText\n\n    // build chord inserts, based on bar or phrase wise changes, each with the text and position where to insert\n    let chordInserts = []\n    for (let group of unit.groups) {\n      let lengthStillToPlaceOnThisGroup = 0\n      let lengthYetPlacedOnThisGroup = 0\n\n      // compute length of all chord inserts\n      for (let chordChange of group.chordChanges[chordChangesMode]) lengthStillToPlaceOnThisGroup += chordChange.text.length\n\n      for (let chordChange of group.chordChanges[chordChangesMode]) {\n        // position of the chord will be the position of the group + length corresponding to offset delta\n        let positionDelta = Math.ceil(((chordChange.offset - group.offset) / group.duration) * group.length)\n        let positionDelta_ = positionDelta\n\n        // ensure that chord name will not cross end of group it belongs to (last char of group must not be overwritten either if it is a bar)\n        while (positionDelta + lengthStillToPlaceOnThisGroup > group.length - (group.bar ? 1 : 0)) { positionDelta-- }\n\n        // ensure that chords already there still have enough room\n        while (positionDelta - lengthYetPlacedOnThisGroup < 0) { positionDelta++ }\n\n        this.log('Closest group \"' + group.text.replace(/\\n/g, '\\\\n') + '\" with offset ' + group.offset + ' and position ' + group.position + ' found for ' + chordChange.text.trim() + ' with offset ' + chordChange.offset + ' units\\n\\tposition delta from group start = ' + positionDelta + ' chars (initially ' + positionDelta_ + ' chars)')\n        chordInserts.push({ text: chordChange.text, offset: chordChange.offset, position: group.position + positionDelta })\n\n        lengthYetPlacedOnThisGroup = positionDelta + chordChange.text.length\n        lengthStillToPlaceOnThisGroup -= chordChange.text.length\n      }\n    }\n\n    for (let chordInsert of chordInserts) this.log('[' + unit.name + '] Should insert ' + chordInsert.text + ' @ ' + chordInsert.offset + ' units / ' + chordInsert.position + ' chars')\n\n    // insert these chord inserts\n    let position = 0\n    let skip = 0\n    let unitText_ = unitText\n    let chordText = ''\n    unitText = ''\n    for (let char of unitText_) {\n      if (char === '\\n') {\n        unitText += '\\n'\n        chordText += '\\n'\n        skip = 0\n      } else {\n        for (let chordInsert of chordInserts) {\n          if (!chordInsert.inserted) {\n            if (chordInsert.position <= position) {\n              this.log('[' + unit.name + '] Inserting ' + chordInsert.text + ' @ ' + position + ' chars')\n              chordText += chordInsert.text\n              chordInsert.inserted = true\n              skip = chordInsert.text.length\n            }\n          }\n        }\n\n        position++\n\n        // add char to unit text, and corresponding space to chord text\n        // only bar symbols are added in chord text instead of unit text (if showing dots, then bars are displayed in both texts)\n        if (skip === 0) { chordText += char === '|' ? char : ' ' } else { skip-- }\n        unitText += char === '|' && !(showDots || this.DEBUG) ? ' ' : char\n      }\n    }\n\n    // and interlace the two strings\n    return Utils.interlace(chordText, unitText, null, KEEP_EMPTY_LINES)\n  }\n\n  registerGroup (unit, offset, step, barDuration) {\n    if (!barDuration) throw new Error('Invalid bar duration passed to registerGroup')\n\n    while (step > 0) {\n      // duration added to preceding group may never be more than what's left until end of bar\n      let addDuration = Math.min(step, barDuration - (offset % barDuration))\n\n      // create a new group if none or if preceding already got its duration\n      if (!unit.groups.length || (!LYRICS_SUM_DURATIONS && unit.groups[unit.groups.length - 1].duration > 0)) unit.groups.push({ text: '', offset: offset, duration: 0 })\n\n      // add this duration to preceding group (create it if needed)\n      unit.groups[unit.groups.length - 1].duration += addDuration\n      offset += addDuration\n      step -= addDuration\n\n      // step is going to cross end of bar: directly create a first empty group\n      if (step > 0) unit.groups.push({ text: this.DEBUG > 1 ? '_' : '', offset: offset, duration: 0 })\n    }\n\n    return offset\n  }\n\n  getGroupLength (group) {\n    // return the number of visible graphemes in group text\n    // - newlines are not counted\n    // - tabs will be converted to spaces and may thus count as 1\n    // - use spread operator to correctly count astral unicode symbols\n    return [...group.text.replace(/\\n/g, '')].length\n  }\n\n  getChordDisplay (chordDuration) {\n    // space and not empty if hidden, to ensure that a white space will show that this change does not happen at the begin of the bar\n    if (chordDuration.hidden) return ' '\n\n    // a space prevents chord names to be glued together on group and prevents a next group from starting directly after last chord of previous group\n    return chordDuration.chord.name + ' '\n  }\n}\n\n/**\n * Public API\n */\n\nexport class Compiler {\n  constructor (songcheat, DEBUG) {\n    this.compiler_ = new Compiler_(DEBUG)\n    if (songcheat) this.set(songcheat)\n  }\n\n  set (songcheat) {\n    this.compiler_.log(Utils.title('COMPILE SONGCHEAT'))\n    this.scc = this.compiler_.compile(JSON.parse(JSON.stringify(songcheat)))\n  }\n\n  parseLyrics (unit) {\n    this.compiler_.log(Utils.title('PARSE LYRICS ' + unit.name))\n    return this.compiler_.parseLyrics(unit, Utils.duration(this.scc.lyricsUnit), this.scc.barDuration)\n  }\n\n  getUnitText (unit, maxConsecutiveSpaces, split, chordChangesMode, showDots) {\n    this.compiler_.log(Utils.title(`GET LYRICS TEXT ${unit.name} (maxConsecutiveSpaces = ${maxConsecutiveSpaces}, split = ${split}, chordChangesMode = ${chordChangesMode}, showDots = ${showDots})`))\n    return this.compiler_.getUnitText(unit, maxConsecutiveSpaces, split, chordChangesMode, showDots)\n  }\n\n  getPartText (part, maxConsecutiveSpaces, split, chordChangesMode, showDots) {\n    // dummy unit with no lyrics\n    let unit = { name: part.name, part: part }\n\n    this.compiler_.log(Utils.title('PARSE PART LYRICS ' + unit.name))\n    this.compiler_.parseLyrics(unit, Utils.duration(this.scc.lyricsUnit), this.scc.barDuration)\n\n    this.compiler_.log(Utils.title(`GET PART LYRICS TEXT ${unit.name} (maxConsecutiveSpaces = ${maxConsecutiveSpaces}, split = ${split}, chordChangesMode = ${chordChangesMode}, showDots = ${showDots})`))\n    return this.compiler_.getUnitText(unit, maxConsecutiveSpaces, split, chordChangesMode, showDots)\n  }\n}\n"]}