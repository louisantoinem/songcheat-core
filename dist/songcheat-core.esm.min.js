class Utils{static title(e){return"\n"+this.spaces(e.length+8,"*")+"\n*** "+e+" ***\n"+this.spaces(e.length+8,"*")+"\n"}static firstUpper(e){return e.charAt(0).toUpperCase()+e.slice(1)}static camelCase(e,t){var r=e.toLowerCase().replace(/(?:[-_])(.)/g,function(e,t){return t.toUpperCase()});return t?r.charAt(0).toUpperCase()+r.slice(1):r}static spaces(e,t){if(isNaN(e)||!isFinite(e)||e<0)throw new Error("Length must a positive finite number");for(var r="",o=0;o<e;o++)r+=t||" ";return r}static interlace(e,t,r,o){var n=e.split(/\r?\n/),i=t.split(/\r?\n/);return n.map(function(e,t){let n=o||i[t]&&i[t].trim()?[e,i[t]]:[e];return"string"==typeof r&&n.push(r),n.join("\n")}).join("\n")}static encodeQueryData(e){let t=[];for(let r in e)t.push(encodeURIComponent(r)+"="+encodeURIComponent(e[r]));return t.join("&")}static duration(e){if(":32"===e)return 2;if(":16"===e)return 4;if(":8"===e)return 8;if(":q"===e)return 16;if(":h"===e)return 32;if(":w"===e)return 64;if(":32d"===e)return 3;if(":16d"===e)return 6;if(":8d"===e)return 12;if(":qd"===e)return 24;if(":hd"===e)return 48;if(":wd"===e)return 96;throw new Error('Invalid duration code "'+e+'"')}static durationcode(e){for(let t of["w","h","q","8","16","32"]){if(this.duration(":"+t)===e)return":"+t;if(this.duration(":"+t+"d")===e)return":"+t+"d"}throw new Error("Could not find a code with a value of "+e+" units")}static durationcodes(e){for(var t=[],r=e,o=0;r>0;)try{t.push(this.durationcode(r)),r=o,o=0}catch(e){r--,o++}if(o>0)throw new Error("Could not find codes adding to a value of "+e+" units");return t}static fret2char(e){if(isNaN(e)||e<0||e>35)throw new Error("Cannot convert fret number "+e+" to a single char (expected a value between 0 and 35)");return e<10?""+e:String.fromCharCode("A".charCodeAt(0)+e-10)}static char2fret(e){if("string"!=typeof e)throw new Error("Invalid fret char "+e+" expected a string");if(!e.match(/^[0-9A-Z]$/))throw new Error("Invalid fret char "+e+" (expected a value between [0-9] or [A-Z])");return e>="A"?10+e.charCodeAt(0)-"A".charCodeAt(0):parseInt(e,10)}static abs2rel(e,t){let r=this.char2fret(e);if(isNaN(r)||r<0)throw new Error("Invalid fret number "+r+" (expected a positive or 0 integer value)");if(0===r)return 0;if(isNaN(t)||t<0)throw new Error("Invalid starting fret number "+t+" (expected a positive or 0 integer value)");if(t+8<r||t>r)throw new Error("Fret "+r+" cannot be made relative to starting fret "+t+" within the allowed range of 1 to 9");return r+1-t}static rel2abs(e,t){return this.fret2char(e?e+t-1:e)}static chordStrings(e,t){if(!e.tablature)throw new Error("Tablature not defined for chord "+e.name);if(!e.fingering)throw new Error("Fingering not defined for chord "+e.name);for(var r=[],o=0;o<e.tablature.length;o++){var n=6-o;if("x"!==e.tablature[o]&&(t=t.replace(/B'/g,n>=5?n-1:n),(t=t.replace(/B/g,n)).match(/^\*/)||-1!==t.indexOf(n))){let i=this.char2fret(e.tablature[o]),a="x"===t[t.match(/^\*/)?1:t.indexOf(n)+1];r.push({string:n,fret:i,mute:a})}}return r}}class ParserException{constructor(e,t){this.message=t,this.line=e}toString(){return"Parser error at line "+this.line+": "+this.message}}class Parser_{constructor(){this.songcheat={},this.blocks={}}parse(e){this.songcheat={},this.blocks={};let t=this.tokenize(e);if(0===t.length)return!0;let r=0;for(;r<t.length;){let e=t[r],o=this.isKeyword(e);if(!o)throw new ParserException(e.line,'expected keyword, found "'+e.value+'"');let n=[];for(++r;r<t.length&&!this.isKeyword(t[r]);++r)n.push(t[r]);let i=this["handle"+Utils.firstUpper(o)]||this.handleDefault;if("function"!=typeof i)throw new ParserException(e.line,"non function handler found for keyword "+o);i.call(this,e.line,o,n)}return this.songcheat}isKeyword(e){let t=Utils.camelCase(e.value);return["artist","title","year","difficulty","video","tutorial","comment","tuning","capo","key","time","tempo","shuffle","chord","rhythm","block","part","lyricsUnit","structure"].indexOf(t)>=0&&t}tokenize(e){let t=[],r=/(?<=^[^"]*(?:"[^"]*"[^"]*)*)[\s\t]+(?=(?:[^"]*"[^"]*")*[^"]*$)/,o=/(?<=^[^"]*(?:"[^"]*"[^"]*)*)(\r?\n)(?=(?:[^"]*"[^"]*")*[^"]*$)/,n=1;for(let i of e.split(o))if(!i.match(/^\r?\n$/)){if((i=i.trim())&&!i.match(/^#/))for(let e of i.split(r).map(e=>e.trim().replace(/^"|"$/g,"")))t.push({value:e,line:n});n+=1+(i.match(/(?:\r?\n)/g)||[]).length}return t}handleDefault(e,t,r){if(1!==r.length)throw new ParserException(e,t.toUpperCase()+" expected exactly 1 value, but found "+r.length);this.songcheat[t]=["year","capo","difficulty"].indexOf(t)>=0?parseInt(r[0].value,10):r[0].value}handleSignature(e,t,r){if(1!==r.length)throw new ParserException(e,t.toUpperCase()+" expected exactly 1 value, but found "+r.length);this.songcheat.signature=this.songcheat.signature||{},this.songcheat.signature[t]="tempo"===t?parseFloat(r[0].value,10):r[0].value}handleKey(e,t,r){return this.handleSignature(e,t,r)}handleTempo(e,t,r){return this.handleSignature(e,t,r)}handleShuffle(e,t,r){return this.handleSignature(e,t,r)}handleTime(e,t,r){if(3!==r.length)throw new ParserException(e,t.toUpperCase()+" expected exactly 3 values, but found "+r.length);this.songcheat.signature=this.songcheat.signature||[],this.songcheat.signature.time={beatsPerBar:r[1].value,beatDuration:r[2].value,symbol:r[0].value}}handleChord(e,t,r){if(r.length<2||r.length>4)throw new ParserException(e,t.toUpperCase()+' expected between 2 and 4 values (name, tablature[, fretting="000000/-", comment=""]), but found '+r.length);let o=r[0].value,n=r[1].value,i=r.length>=3?r[2].value:"000000/-",a=r.length>=4?r[3].value:"";this.songcheat.chords=this.songcheat.chords||[];let s={id:this.songcheat.chords.length+1,name:o,tablature:n,fingering:i,comment:a};return this.songcheat.chords.push(s),s}handleRhythm(e,t,r){if(2!==r.length)throw new ParserException(e,t.toUpperCase()+" expected exactly 2 values (id and score), but found "+r.length);this.songcheat.rhythms=this.songcheat.rhythms||[],this.songcheat.rhythms.push({id:this.songcheat.rhythms.length+1,name:r[0].value,score:r[1].value})}handleBlock(e,t,r){if(r.length<2)throw new ParserException(e,t.toUpperCase()+" expected at least 2 values (name and bar(s)), but found "+r.length);this.blocks[r[0].value]=r.slice(1)}handlePart(e,t,r){if(r.length<2)throw new ParserException(e,t.toUpperCase()+" expected at least 2 values (name and bar(s)), but found "+r.length);this.songcheat.parts=this.songcheat.parts||[];let o={id:this.songcheat.parts.length+1,name:r[0].value,phrases:[]};r=r.splice(1),this.songcheat.parts.push(o);let n=[];for(let e=0;e<r.length;e++){let t=r[e];if("||"===t.value){o.phrases.push({bars:n}),n=[];continue}if("%"===t.value){if(0===n.length)throw new ParserException(t.line,"found bar repeater "+t.value+" but there is no bar yet in phrase");n.push(JSON.parse(JSON.stringify(n[n.length-1])));continue}if(t.value.match(/^\[[^[\]]+\]$/)){let e={rhythm:null,chords:[]},r=t.value.substr(1,t.value.length-2).split(/\*|:/),o=!1;for(let t of this.songcheat.rhythms)if(t.name===r[0]){e.rhythm=t.id,o=!0;break}if(!o)throw new ParserException(t.line,r[0]+" is not the name of an existing rhythm");r=r.slice(1);for(let o of r){if(!o.trim()){if(0===e.chords.length)throw new ParserException(t.line,"found chord repeater but there is no chord yet in bar");e.chords.push(JSON.parse(JSON.stringify(e.chords[e.chords.length-1])));continue}let r=!1;for(let t of this.songcheat.chords)if(t.name===o){e.chords.push(t.id),r=!0;break}if(!r&&o.match(/^[x0-9A-Z]{6}(\/[-0-9A-Z])?$/)){let n=this.handleChord(t.line,"chord",[{value:o,line:t.line},{value:o.split("/")[0],line:t.line},{value:"000000/"+(o.split("/")[1]||"-"),line:t.line}]);e.chords.push(n.id),r=!0}if(!r)throw new ParserException(t.line,o+" is not the name of an existing chord and is not a valid chord tablature")}n.push(e);continue}if(!this.blocks[t.value])throw new ParserException(t.line,t.value+" is not the name of an existing block");let i=[e,1];Array.prototype.push.apply(i,this.blocks[t.value]),Array.prototype.splice.apply(r,i),e--}n.length>0&&o.phrases.push({bars:n})}handleStructure(e,t,r){if(r.length<2)throw new ParserException(e,t.toUpperCase()+" expected at least 2 values (part name and lyrics), but found "+r.length);if(r.length%2!=0)throw new ParserException(e,t.toUpperCase()+" expected an even number of parameters (N x part name and lyrics), but found "+r.length);this.songcheat.structure=this.songcheat.structure||[];for(let e=0;e<r.length;e+=2){let t=r[e],o=!1;for(let n of this.songcheat.parts)if(n.name===t.value){this.songcheat.structure.push({part:n.id,lyrics:r[e+1].value}),o=!0;break}if(!o)throw new ParserException(t.line,t.value+'" is not the name of an existing part')}}}class Parser{constructor(){this.parser_=new Parser_}parse(e){return this.parser_.parse(e)}}let MIN_LYRICS_BARLEN=20,LYRICS_SUM_DURATIONS=!1,KEEP_EMPTY_LINES=!1;class CompilerException{constructor(e){this.message=e}toString(){return"Compiler error: "+this.message}}class Compiler_{constructor(e){this.DEBUG=e}log(){this.DEBUG>0&&console.log.apply(console,arguments)}compile(e){if(e.mode=e.mode||"rt",e.barsPerLine=e.barsPerLine||4,e.signature.key=e.signature.key||"C",e.lyricsUnit=e.lyricsUnit||e.signature.time.beatDuration,e.barDuration=e.signature.time.beatsPerBar*Utils.duration(e.signature.time.beatDuration),this.resolveIds(e),!e.parts){e.parts=[];for(let t of e.parts)e.structure.push({part:t})}let t={},r={};for(let r of e.structure)t[r.part.id]=void 0===t[r.part.id]?1:t[r.part.id]+1;for(let o of e.structure)r[o.part.id]=void 0===r[o.part.id]?1:r[o.part.id]+1,o.name||(o.name=o.part.name+(t[o.part.id]>1?" "+r[o.part.id]:""));let o=["red","#06D6A0","blue","purple","orange","magenta"],n=0;for(let t of e.parts)t.color||(t.color=o[n++%o.length]);for(let t of e.rhythms)this.compileRhythm(t,e.signature.time.beatDuration);for(let t of e.parts){let r=0;for(let o of t.phrases){o.chordChanges=[];let n=null;for(let t of o.bars)n=this.addChordChanges(t,o.chordChanges,e.barDuration,!1,n);this.log("Phrase wise chord durations for phrase "+t.name+"."+(r+1));for(let e of o.chordChanges)this.log("\t["+e.chord.name+"] = "+e.duration+" units");let i=0;for(let n of o.bars){n.chordChanges={bar:[],rhythm:[]};for(let t of["rhythm","bar"])this.addChordChanges(n,n.chordChanges[t],e.barDuration,"bar"===t);this.log("\tRythm wise chord durations for bar "+t.name+"."+(r+1)+"."+(i+1));for(let e of n.chordChanges.rhythm)this.log("\t\t["+e.chord.name+"] = "+e.duration+" units");this.log("\tBar wise chord durations for bar "+t.name+"."+(r+1)+"."+(i+1));for(let e of n.chordChanges.bar)this.log("\t\t["+e.chord.name+"] = "+e.duration+" units");i++}r++}t.duration=0;for(let e of t.phrases)for(let r of e.bars)t.duration+=r.rhythm.duration}return e}resolveIds(e){let t=0;for(let r of e.structure){if(!r.part)throw new CompilerException("Part not defined for unit "+(t+1));let o=this.resolveId(e.parts,r.part);if(!o)throw new CompilerException("Part "+r.part+" not found");r.part=o,t++}for(let t of e.parts){if(!t.phrases)throw new CompilerException('Phrases not defined for part "'+t.name+'"');if(!(t.phrases instanceof Array))throw new CompilerException('Phrases defined for part "'+t.name+'" must be an Array, found: '+typeof e.parts.phrases);let r=0;for(let o of t.phrases){let n=0;for(let i of o.bars){if(!i.rhythm)throw new CompilerException("Rhythm not defined for bar "+(n+1)+" of phrase "+(r+1)+" of "+t.name);if(!i.chords)throw new CompilerException("Chords not defined for bar "+(n+1)+" of phrase "+(r+1)+" of "+t.name);if(!(i.chords instanceof Array))throw new CompilerException("Chords defined for bar "+(n+1)+" of phrase "+(r+1)+" must be an Array, found: "+typeof i.chords);let o=this.resolveId(e.rhythms,i.rhythm);if(!o)throw new CompilerException("Rhythm "+i.rhythm+" not found for bar "+(n+1)+" of phrase "+(r+1));i.rhythm=o;let a=[];for(let t of i.chords){let o=this.resolveId(e.chords,t);if(!o)throw new CompilerException("Chord "+t+" not found for bar "+(n+1)+" of phrase "+(r+1));a.push(o)}i.chords=a,n++}r++}}}resolveId(e,t){if(e)for(let r of e)if(r.id===t)return r;return null}compileRhythm(e,t){this.log("Compiling rhythm "+e.id+' with score "'+e.score+'"');let r=t;e.placeholdercount=0;let o=1,n=null;e.compiledScore=[];for(let t of e.score.split(/((?::(?:w|h|q|8|16|32)d?)|\(#\)|T?\s*\([^(]*\)[^()\sT:]*)/)){if(t=t.trim()){let i=null;if(i=t.match(/^(:(?:w|h|q|8|16|32)d?)$/))r=Utils.duration(i[1]);else if(i=t.match(/^\(#\)$/))e.compiledScore.push({rest:!0,duration:r,tied:!1,strings:!1,flags:{},placeholderIndex:e.placeholdercount++});else{if(!(i=t.match(/^(T?)\s*\(([^(]*)\)([^()\s]*)$/)))throw new CompilerException('Invalid token "'+t+'" in rhythm score definition at position '+o+(n?' (after "'+n+'")':""));{let o="T"===i[1],n=i[2];if(""===n&&(n="*"),"x"===n&&(n="*x"),!n.match(/^(?:(\*x?)|((?:(?:B|B'|1|2|3|4|5|6)x?)+))$/))throw new CompilerException("Invalid syntax found in chord placeholder: "+n);let a=i[3],s={stroke:null,accent:!1,pm:!1,fingering:null};for(let e of a.split(/(dd?|uu?|>|PM|[pima]+)/))if(e.trim())if(e.match(/^(dd?|uu?)$/g)){if(s.fingering)throw new CompilerException("Fingering ("+s.fingering+") and stroke ("+e+") cannot be both defined for the chord placeholder: "+t);if(s.pm)throw new CompilerException("Palm muting (PM) and stroke ("+e+") cannot be both defined for the chord placeholder: "+t);if(s.stroke)throw new CompilerException("More than one stroke mode (d, u, dd, uu) defined for the chord placeholder: "+t);s.stroke=e}else if(e.match(/^[pima]+$/)){if(s.stroke)throw new CompilerException("Stroke ("+s.stroke+") and fingering ("+e+") cannot be both defined for the chord placeholder: "+t);if(s.pm)throw new CompilerException("Palm muting (PM) and fingering ("+e+") cannot be both defined for the chord placeholder: "+t);if(s.fingering)throw new CompilerException("More than one fingering (pima) defined for the chord placeholder: "+t);s.fingering=e}else if(e.match(/^PM$/)){if(s.stroke)throw new CompilerException("Stroke ("+s.stroke+") and palm muting ("+e+") cannot be both defined for the chord placeholder: "+t);if(s.fingering)throw new CompilerException("Fingering ("+s.fingering+") and palm muting ("+e+") cannot be both defined for the chord placeholder: "+t);if(s.pm)throw new CompilerException("More than one palm muting (PM) defined for the chord placeholder: "+t);s.pm=!0}else{if(!e.match(/^>$/))throw new CompilerException('Invalid flag "'+e+'" defined for chord placeholder "'+t+'"');if(s.accent)throw new CompilerException("More than one accent (>) defined for the same placeholder: "+t);s.accent=!0}e.compiledScore.push({rest:!1,duration:r,tied:o,strings:n,flags:s,placeholderIndex:e.placeholdercount++})}}n=t}o+=t.length}e.duration=0;for(let t of e.compiledScore)e.duration+=t.duration}addChordChanges(e,t,r,o,n){if(e.chords.length<1)throw new CompilerException("chords must contain at least 1 entry, but "+e.chords.length+" were found");for(;e.chords.length<e.rhythm.placeholdercount;)e.chords.push(e.chords[e.chords.length-1]);let i=0;for(let a of e.rhythm.compiledScore){let s=e.chords[a.placeholderIndex];if(!s)throw new CompilerException("No chord found for placeholder "+(a.placeholderIndex+1));n===s&&i%r!=0?t[t.length-1].duration+=a.duration:t.push({chord:s,duration:a.duration,hidden:n===s&&!o}),n=s,i+=a.duration}return n}parseLyrics(e,t,r){let o=[],n=0;e.lyrics=(e.lyrics||"").replace(/\r/g,""),e.groups=[];for(let o of e.lyrics.split(/((?::(?:w|h|q|8|16|32)d?)?:|\|)/)){let i=null;(i=o.match(/(:(?:w|h|q|8|16|32)d?)?:/))?n=this.registerGroup(e,n,i[1]?Utils.duration(i[1]):t,r):o.match(/\|/)?n=this.registerGroup(e,n,r-n%r,r):o.length>0&&e.groups.push({text:o,offset:n,duration:0})}e.groups.length&&0===e.groups[e.groups.length-1].duration&&(n=this.registerGroup(e,n,r-n%r,r));let i=e.part.duration-n;this.log("["+e.name+"] Missing duration = "+i+" units ("+e.part.duration+" - "+n+") = "+i/r+" bars missing"),i<0&&o.push("Lyrics contain "+Math.floor(-i/r)+" bar(s)"+(-i%r?" and "+Utils.durationcodes(-i%r):"")+" in excess"),n=this.registerGroup(e,n,i,r);for(let t of e.groups){let e=this.getGroupLength(t)+1;t.plen=Math.max(e,Math.ceil(MIN_LYRICS_BARLEN*t.duration/r)),t.p=t.plen/t.duration,t.bar=(t.offset+t.duration)%r==0,t.chordChanges={bar:[],rhythm:[],phrase:[]}}e.pmax=0;for(let t of e.groups)e.pmax=Math.max(e.pmax,t.p);n=0;for(let t of e.part.phrases)for(let r of t.chordChanges){let t=null;for(let r of e.groups)r.offset<=n&&(t=r);if(!t)throw new Error("No closest group found for chord "+r.chord.name+" with offset "+n+" units");t.chordChanges.phrase.push({offset:n,text:this.getChordDisplay(r)}),n+=r.duration}n={rhythm:0,bar:0};for(let t of e.part.phrases)for(let r of t.bars)for(let t of["rhythm","bar"])for(let o of r.chordChanges[t]){let r=null;for(let o of e.groups)o.offset<=n[t]&&(r=o);if(!r)throw new Error("No closest group found for chord "+o.chord.name+" with offset "+n[t]+" units");r.chordChanges[t].push({offset:n[t],text:this.getChordDisplay(o)}),n[t]+=o.duration}var a="Groups of unit ["+e.name+"]:\n",s=0;let h=!1;for(let t of e.groups)a+="\tBar "+(s+1)+"\t["+t.text.replace(/\n/g,"\\N")+"]:"+t.duration+" ("+t.offset+" - "+(t.offset+t.duration)+") L="+this.getGroupLength(t)+" L'="+t.plen+" ρ="+t.p.toFixed(2)+" #Chord changes %bar= "+t.chordChanges.bar.length+" %phrase= "+t.chordChanges.phrase.length,0===t.duration&&(h=!0),t.bar&&(s++,a+=" | "),a+="\n";if(a+="ρ max = "+e.pmax.toFixed(2),this.log(a),h)throw new Error("Detected group with 0 duration");return o}getUnitText(e,t,r,o,n){var i="",a=0,s=0;for(let l of e.groups){l.position=[...i.replace(/\n/g,"")].length,l.length=Math.ceil(l.duration*e.pmax);let c=l.bar||!l.text.match(/-$/),p=null;t>0&&(p=this.getGroupLength(l)+t-(c?0:1)),p&&(l.length=Math.min(l.length,p));let f=l.bar?1:0;if(l.chordChanges[o])for(let e=0;e<l.chordChanges[o].length;e++)f+=l.chordChanges[o][e].text.length;f=Math.max(this.getGroupLength(l)+(c?1:0),f),l.length=Math.max(l.length,f);let d=Utils.spaces(l.length-this.getGroupLength(l),n||this.DEBUG?".":" ");d=d.replace(/(.)$/,l.bar?r>0&&(a+1)%r==0?"|\n":"|":this.DEBUG?"*":"$1");var h=(r>0?l.text.replace(/\n/g,""):l.text)+d;this.log("["+e.name+"] Display group "+(s+1)+' "'+h.replace(/\n/g,"\\N")+'" on '+l.length+" chars (CEIL "+(l.duration*e.pmax).toFixed(2)+" MIN "+f+" MAX "+(p||"n/a")+")"),i+=h,s++,l.bar&&a++}if(!o)return i;let l=[];for(let t of e.groups){let e=0,r=0;for(let r of t.chordChanges[o])e+=r.text.length;for(let n of t.chordChanges[o]){let o=Math.ceil((n.offset-t.offset)/t.duration*t.length),i=o;for(;o+e>t.length-(t.bar?1:0);)o--;for(;o-r<0;)o++;this.log('Closest group "'+t.text.replace(/\n/g,"\\n")+'" with offset '+t.offset+" and position "+t.position+" found for "+n.text.trim()+" with offset "+n.offset+" units\n\tposition delta from group start = "+o+" chars (initially "+i+" chars)"),l.push({text:n.text,offset:n.offset,position:t.position+o}),r=o+n.text.length,e-=n.text.length}}for(let t of l)this.log("["+e.name+"] Should insert "+t.text+" @ "+t.offset+" units / "+t.position+" chars");let c=0,p=0,f=i,d="";i="";for(let t of f)if("\n"===t)i+="\n",d+="\n",p=0;else{for(let t of l)t.inserted||t.position<=c&&(this.log("["+e.name+"] Inserting "+t.text+" @ "+c+" chars"),d+=t.text,t.inserted=!0,p=t.text.length);c++,0===p?d+="|"===t?t:" ":p--,i+="|"!==t||n||this.DEBUG?t:" "}return Utils.interlace(d,i,null,KEEP_EMPTY_LINES)}registerGroup(e,t,r,o){if(!o)throw new Error("Invalid bar duration passed to registerGroup");for(;r>0;){let n=Math.min(r,o-t%o);(!e.groups.length||!LYRICS_SUM_DURATIONS&&e.groups[e.groups.length-1].duration>0)&&e.groups.push({text:"",offset:t,duration:0}),e.groups[e.groups.length-1].duration+=n,t+=n,(r-=n)>0&&e.groups.push({text:this.DEBUG>1?"_":"",offset:t,duration:0})}return t}getGroupLength(e){return[...e.text.replace(/\n/g,"")].length}getChordDisplay(e){return e.hidden?" ":e.chord.name+" "}}class Compiler{constructor(e,t){this.compiler_=new Compiler_(t),e&&this.set(e)}set(e){this.compiler_.log(Utils.title("COMPILE SONGCHEAT")),this.scc=this.compiler_.compile(JSON.parse(JSON.stringify(e)))}parseLyrics(e){return this.compiler_.log(Utils.title("PARSE LYRICS "+e.name)),this.compiler_.parseLyrics(e,Utils.duration(this.scc.lyricsUnit),this.scc.barDuration)}getUnitText(e,t,r,o,n){return this.compiler_.log(Utils.title(`GET LYRICS TEXT ${e.name} (maxConsecutiveSpaces = ${t}, split = ${r}, chordChangesMode = ${o}, showDots = ${n})`)),this.compiler_.getUnitText(e,t,r,o,n)}getPartText(e,t,r,o,n){let i={name:e.name,part:e};return this.compiler_.log(Utils.title("PARSE PART LYRICS "+i.name)),this.compiler_.parseLyrics(i,Utils.duration(this.scc.lyricsUnit),this.scc.barDuration),this.compiler_.log(Utils.title(`GET PART LYRICS TEXT ${i.name} (maxConsecutiveSpaces = ${t}, split = ${r}, chordChangesMode = ${o}, showDots = ${n})`)),this.compiler_.getUnitText(i,t,r,o,n)}}export{Utils,Parser,ParserException,Compiler,CompilerException};